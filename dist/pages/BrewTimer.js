/* src/pages/BrewTimer.svelte generated by Svelte v3.29.7 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import { writable } from "../../web_modules/svelte/store.js";
import { _ } from "../../web_modules/svelte-i18n.js";
import Button from "../components/Button.js";
import Water from "../components/Water.js";

function create_if_block(ctx) {
	let t0_value = /*$_*/ ctx[3]("fill") + "";
	let t0;
	let t1;
	let t2_value = /*$_*/ ctx[3]("number") + "";
	let t2;
	let t3;
	let t4;

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			t4 = text(/*counterValue*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			insert(target, t4, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$_*/ 8 && t0_value !== (t0_value = /*$_*/ ctx[3]("fill") + "")) set_data(t0, t0_value);
			if (dirty & /*$_*/ 8 && t2_value !== (t2_value = /*$_*/ ctx[3]("number") + "")) set_data(t2, t2_value);
			if (dirty & /*counterValue*/ 1) set_data(t4, /*counterValue*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
			if (detaching) detach(t4);
		}
	};
}

// (35:6) <Button on:click={startFill} disabled={fill}>
function create_default_slot(ctx) {
	let t_value = (/*fill*/ ctx[1]
	? /*$_*/ ctx[3]("wait")
	: /*$_*/ ctx[3]("start")) + "";

	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*fill, $_*/ 10 && t_value !== (t_value = (/*fill*/ ctx[1]
			? /*$_*/ ctx[3]("wait")
			: /*$_*/ ctx[3]("start")) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let h1;
	let t1;
	let water;
	let t2;
	let p;
	let t3;
	let button;
	let current;

	water = new Water({
			props: {
				filling: /*fill*/ ctx[1],
				fillCount: /*counterValue*/ ctx[0]
			}
		});

	water.$on("drain", /*resetButton*/ ctx[6]);
	let if_block = /*$counter*/ ctx[2] && create_if_block(ctx);

	button = new Button({
			props: {
				disabled: /*fill*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*startFill*/ ctx[5]);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			h1 = element("h1");
			h1.textContent = "Brewing counter";
			t1 = space();
			create_component(water.$$.fragment);
			t2 = space();
			p = element("p");
			if (if_block) if_block.c();
			t3 = space();
			create_component(button.$$.fragment);
			attr(h1, "class", "mb-8 ps-4 flex justify-center");
			attr(p, "class", "mb-4 p-4 flex justify-center");
			attr(div0, "class", "flex flex-col bg-white rounded shadow p-8");
			attr(div1, "class", "flex flex-col items-center justify-center mt-4");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, h1);
			append(div0, t1);
			mount_component(water, div0, null);
			append(div0, t2);
			append(div0, p);
			if (if_block) if_block.m(p, null);
			append(div0, t3);
			mount_component(button, div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const water_changes = {};
			if (dirty & /*fill*/ 2) water_changes.filling = /*fill*/ ctx[1];
			if (dirty & /*counterValue*/ 1) water_changes.fillCount = /*counterValue*/ ctx[0];
			water.$set(water_changes);

			if (/*$counter*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(p, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const button_changes = {};
			if (dirty & /*fill*/ 2) button_changes.disabled = /*fill*/ ctx[1];

			if (dirty & /*$$scope, fill, $_*/ 266) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(water.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(water.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(water);
			if (if_block) if_block.d();
			destroy_component(button);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $counter;
	let $_;
	component_subscribe($$self, _, $$value => $$invalidate(3, $_ = $$value));
	let counter = writable(0);
	component_subscribe($$self, counter, value => $$invalidate(2, $counter = value));
	let counterValue = 0;

	let unsubscribeCounter = counter.subscribe(value => {
		$$invalidate(0, counterValue = value);
	});

	// let fill = writable(false);
	let fill = false;

	function startFill() {
		counter.update(v => v + 1);

		// fill.set(true);
		$$invalidate(1, fill = true);
	}

	function resetButton() {
		console.log("on drain end");

		// fill.set(false);
		$$invalidate(1, fill = false);
	}

	return [counterValue, fill, $counter, $_, counter, startFill, resetButton];
}

class BrewTimer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default BrewTimer;