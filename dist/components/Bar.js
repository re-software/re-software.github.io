import './Bar.css.proxy.js';
/* src/components/Bar.svelte generated by Svelte v3.29.7 */
import {
	SvelteComponent,
	append,
	attr,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal,
	set_data,
	space,
	svg_element,
	text,
	toggle_class
} from "../../web_modules/svelte/internal.js";

function create_fragment(ctx) {
	let div;
	let svg;
	let g;
	let circle;
	let path;
	let path_class_value;
	let t0;
	let span;
	let t1_value = formatTime(/*timeLeft*/ ctx[1]) + "";
	let t1;

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			g = svg_element("g");
			circle = svg_element("circle");
			path = svg_element("path");
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			attr(circle, "class", "base-timer__path-elapsed svelte-wkxlqh");
			attr(circle, "cx", "50");
			attr(circle, "cy", "50");
			attr(circle, "r", "45");
			attr(path, "id", "base-timer-path-remaining");
			attr(path, "stroke-dasharray", /*circleDasharray*/ ctx[2]);
			attr(path, "class", path_class_value = "base-timer__path-remaining $" + /*remainingPathColor*/ ctx[3] + " svelte-wkxlqh");
			attr(path, "d", "\n            M 50, 50\n            m -45, 0\n            a 45,45 0 1,0 90,0\n            a 45,45 0 1,0 -90,0\n          ");
			attr(g, "class", "base-timer__circle svelte-wkxlqh");
			attr(svg, "class", "base-timer__svg svelte-wkxlqh");
			attr(svg, "viewBox", "0 0 100 100");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(span, "id", "base-timer-label");
			attr(span, "class", "base-timer__label svelte-wkxlqh");
			attr(div, "class", "base-timer svelte-wkxlqh");
			toggle_class(div, "times-up", !!/*timesUp*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);
			append(svg, g);
			append(g, circle);
			append(g, path);
			append(div, t0);
			append(div, span);
			append(span, t1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*circleDasharray*/ 4) {
				attr(path, "stroke-dasharray", /*circleDasharray*/ ctx[2]);
			}

			if (dirty & /*timeLeft*/ 2 && t1_value !== (t1_value = formatTime(/*timeLeft*/ ctx[1]) + "")) set_data(t1, t1_value);

			if (dirty & /*timesUp*/ 1) {
				toggle_class(div, "times-up", !!/*timesUp*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

const FULL_DASH_ARRAY = 283;
const WARNING_THRESHOLD = 10;
const ALERT_THRESHOLD = 5;

function formatTime(time) {
	const minutes = Math.floor(time / 60);
	let seconds = time % 60;

	if (seconds < 10) {
		seconds = `0${seconds}`;
	}

	return `${minutes}:${seconds}`;
}

function instance($$self, $$props, $$invalidate) {
	let { timeLimit = 30 } = $$props;
	let { start = false } = $$props;

	// [todo] try to not use this var
	let timesUp = true;

	const COLOR_CODES = {
		info: { color: "green" },
		warning: {
			color: "orange",
			threshold: WARNING_THRESHOLD
		},
		alert: { color: "red", threshold: ALERT_THRESHOLD }
	};

	let timePassed = 0;
	let timeLeft = timeLimit;
	let timerInterval = null;
	let remainingPathColor = COLOR_CODES.info.color;
	let circleDasharray = "283";

	//     document.getElementById("app").innerHTML = `
	// <div class="base-timer">
	//   <svg class="base-timer__svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
	//     <g class="base-timer__circle">
	//       <circle class="base-timer__path-elapsed" cx="50" cy="50" r="45"></circle>
	//       <path
	//         id="base-timer-path-remaining"
	//         stroke-dasharray="283"
	//         class="base-timer__path-remaining ${remainingPathColor}"
	//         d="
	//           M 50, 50
	//           m -45, 0
	//           a 45,45 0 1,0 90,0
	//           a 45,45 0 1,0 -90,0
	//         "
	//       ></path>
	//     </g>
	//   </svg>
	//   <span id="base-timer-label" class="base-timer__label">${formatTime(
	//       timeLeft
	//   )}</span>
	// </div>
	// `;
	function onTimesUp() {
		clearInterval(timerInterval);
		$$invalidate(0, timesUp = true);
		timePassed = 0;
		$$invalidate(2, circleDasharray = "283");
	}

	function startTimer() {
		$$invalidate(0, timesUp = false);

		if (timerInterval) {
			clearInterval(timerInterval);
		}

		timerInterval = setInterval(
			() => {
				timePassed = timePassed += 1;
				$$invalidate(1, timeLeft = timeLimit - timePassed);

				// document.getElementById("base-timer-label").innerHTML = formatTime(
				//     timeLeft
				// );
				setCircleDasharray();

				// setRemainingPathColor(timeLeft);
				if (timeLeft === 0) {
					onTimesUp();
				}
			},
			1000
		);
	}

	// function setRemainingPathColor(timeLeft) {
	//     const { alert, warning, info } = COLOR_CODES;
	//     if (timeLeft <= alert.threshold) {
	//         document
	//             .getElementById("base-timer-path-remaining")
	//             .classList.remove(warning.color);
	//         document
	//             .getElementById("base-timer-path-remaining")
	//             .classList.add(alert.color);
	//     } else if (timeLeft <= warning.threshold) {
	//         document
	//             .getElementById("base-timer-path-remaining")
	//             .classList.remove(info.color);
	//         document
	//             .getElementById("base-timer-path-remaining")
	//             .classList.add(warning.color);
	//     }
	// }
	function calculateTimeFraction() {
		const rawTimeFraction = timeLeft / timeLimit;
		return rawTimeFraction - 1 / timeLimit * (1 - rawTimeFraction);
	}

	function setCircleDasharray() {
		$$invalidate(2, circleDasharray = `${(calculateTimeFraction() * FULL_DASH_ARRAY).toFixed(0)} 283`);
	} // document
	//     .getElementById("base-timer-path-remaining")

	$$self.$$set = $$props => {
		if ("timeLimit" in $$props) $$invalidate(5, timeLimit = $$props.timeLimit);
		if ("start" in $$props) $$invalidate(4, start = $$props.start);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*start, timeLimit*/ 48) {
			$: {
				console.log(start, timeLimit, "timer");

				if (start) {
					$$invalidate(4, start = false);
					startTimer();
				}
			}
		}
	};

	return [timesUp, timeLeft, circleDasharray, remainingPathColor, start, timeLimit];
}

class Bar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { timeLimit: 5, start: 4 });
	}
}

export default Bar;